<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ò–≥—Ä—ã: –¶–≤–µ—Ç –∏ –§–æ—Ä–º–∞</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css?v=2" />
  <script src="voice.js"></script>
</head>
<body>
  <!-- –ú–µ–Ω—é -->
  <div class="screen active" id="menuScreen">
    <div class="screen-inner">
      <h1>–î–µ—Ç—Å–∫–∏–µ –∏–≥—Ä—ã: –¶–≤–µ—Ç –∏ –§–æ—Ä–º–∞</h1>
      <p>–í—ã–±–µ—Ä–∏ –∏–≥—Ä—É:</p>
      <div class="menu-buttons">
        <button class="menu-btn" data-mode="color">
          –ò–≥—Ä–∞ ¬´–ù–∞–π–¥–∏ —Ü–≤–µ—Ç¬ª
          <span>–Ω–∞–∂–º–∏ –Ω–∞ –Ω—É–∂–Ω—ã–π —Ü–≤–µ—Ç</span>
        </button>
        <button class="menu-btn" data-mode="shape">
          –ò–≥—Ä–∞ ¬´–ù–∞–π–¥–∏ —Ñ–æ—Ä–º—É¬ª
          <span>–∫—Ä—É–≥, –∫–≤–∞–¥—Ä–∞—Ç, —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫</span>
        </button>
        <button class="menu-btn" data-mode="both">
          –ò–≥—Ä–∞ ¬´–¶–≤–µ—Ç + —Ñ–æ—Ä–º–∞¬ª
          <span>–Ω–∞–π–¥–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä, –∫—Ä–∞—Å–Ω—ã–π –∫—Ä—É–≥</span>
        </button>
      </div>
    </div>
  </div>

  <!-- –≠–∫—Ä–∞–Ω –∏–≥—Ä—ã -->
  <div class="screen" id="gameScreen">
    <div class="screen-inner">
      <h2 id="gameTitle">–ò–≥—Ä–∞</h2>

      <div class="task" id="taskText">
        –ù–∞–∂–º–∏ –Ω–∞ —Ü–≤–µ—Ç: <span class="highlight" id="taskHighlight">...</span>
      </div>

      <div class="shapes" id="shapes"></div>

      <div class="info">
        –°—á—ë—Ç: <span class="score" id="score">0</span>
      </div>

      <div class="btn-row">
        <button class="btn" id="nextBtn">–°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥</button>
        <button class="btn secondary" id="backBtn">–ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é</button>
      </div>

      <!-- —Å–ª–æ–π –¥–ª—è —Å–º–∞–π–ª–∏–∫–æ–≤ -->
      <div id="emojiLayer" class="game-emoji-layer"></div>
    </div>
  </div>

  <script>
    const bodyEl = document.body;

    // –û–¥–∏–Ω –∏—Å—Ç–æ—á–Ω–∏–∫ –ø—Ä–∞–≤–¥—ã –¥–ª—è —Ü–≤–µ—Ç–æ–≤
    const COLORS = [
      { key: 'red',    nameRu: '–∫—Ä–∞—Å–Ω—ã–π',    hex: '#ef4444' },
      { key: 'blue',   nameRu: '—Å–∏–Ω–∏–π',      hex: '#3b82f6' },
      { key: 'green',  nameRu: '–∑–µ–ª—ë–Ω—ã–π',    hex: '#22c55e' },
      { key: 'yellow', nameRu: '–∂—ë–ª—Ç—ã–π',     hex: '#eab308' },
      { key: 'purple', nameRu: '—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π', hex: '#a855f7' },
      { key: 'orange', nameRu: '–æ—Ä–∞–Ω–∂–µ–≤—ã–π',  hex: '#f97316' }
    ];

    const SHAPES = [
      { key: 'circle',   nameRu: '–∫—Ä—É–≥' },
      { key: 'square',   nameRu: '–∫–≤–∞–¥—Ä–∞—Ç' },
      { key: 'triangle', nameRu: '—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫' }
    ];

    const menuScreen   = document.getElementById('menuScreen');
    const gameScreen   = document.getElementById('gameScreen');
    const gameTitleEl  = document.getElementById('gameTitle');
    const taskTextEl   = document.getElementById('taskText');
    const shapesCont   = document.getElementById('shapes');
    const scoreEl      = document.getElementById('score');
    const nextBtn      = document.getElementById('nextBtn');
    const backBtn      = document.getElementById('backBtn');
    const emojiLayer   = document.getElementById('emojiLayer');

    let currentMode = 'color';   // 'color' | 'shape' | 'both'
    let currentTarget = null;    // { colorKey?, shapeKey? }
    let currentTaskText = '';
    let score = 0;
    let canClick = true;

    const correctSound = new Audio('./correct.mp3');
    const wrongSound   = new Audio('./wrong.mp3');
    correctSound.volume = 0.7;
    wrongSound.volume   = 0.7;

    bodyEl.classList.add('menu-bg');

    function showScreen(id) {
      menuScreen.classList.remove('active');
      gameScreen.classList.remove('active');
      document.getElementById(id).classList.add('active');
    }

    function getRandomFrom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function getRandomItems(arr, count) {
      const pool = [...arr];
      const res = [];
      while (res.length < count && pool.length > 0) {
        const idx = Math.floor(Math.random() * pool.length);
        res.push(pool.splice(idx, 1)[0]);
      }
      return res;
    }

    function clearHighlights(container) {
      container.querySelectorAll('.shape').forEach(el => {
        el.classList.remove('correct', 'wrong');
      });
    }

    function speakTask() {
      if (currentTaskText && typeof speak === 'function') {
        speak(currentTaskText, 'ru-RU');
      }
    }

    // –í—Å–ø–ª—ã–≤–∞—é—â–∏–µ —Å–º–∞–π–ª–∏–∫–∏
function showEmojiBurst(targetEl, isCorrect) {
  if (!emojiLayer || !targetEl) return;

  const emojis = isCorrect
    ? ['üòÄ','üòÑ','üéâ','‚≠ê','üëè']
    : ['üòï','üòû','üôà','‚òÅÔ∏è'];

  const rect = targetEl.getBoundingClientRect();
  const parentRect = emojiLayer.getBoundingClientRect();
  const baseX = rect.left + rect.width / 2 - parentRect.left;
  const baseY = rect.top + rect.height / 2 - parentRect.top;

  const count = 4;
  for (let i = 0; i < count; i++) {
    const span = document.createElement('span');
    span.className = 'emoji-burst';
    span.textContent = emojis[Math.floor(Math.random() * emojis.length)];

    // —Å—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è ‚Äî —Ü–µ–Ω—Ç—Ä —Ñ–∏–≥—É—Ä—ã
    span.style.left = baseX + 'px';
    span.style.top = baseY + 'px';

    // —Å–ª—É—á–∞–π–Ω—ã–π —É–≥–æ–ª –∏ —Å–∏–ª–∞ —Ä–∞–∑–ª—ë—Ç–∞
    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.6 - 0.3;
    const distance = 60 + Math.random() * 40; // 60‚Äì100px

    span.style.setProperty('--dx', (Math.cos(angle) * distance).toFixed(1) + 'px');
    span.style.setProperty('--dy', (Math.sin(angle) * distance).toFixed(1) + 'px');

    emojiLayer.appendChild(span);

    setTimeout(() => span.remove(), 750);
  }
}
    function startGame(mode) {
      currentMode = mode;
      score = 0;
      scoreEl.textContent = score;

      bodyEl.classList.remove('menu-bg', 'color-bg', 'shape-bg', 'both-bg');
      if (mode === 'color') {
        bodyEl.classList.add('color-bg');
        gameTitleEl.textContent = '–ò–≥—Ä–∞ ¬´–ù–∞–π–¥–∏ —Ü–≤–µ—Ç¬ª';
      } else if (mode === 'shape') {
        bodyEl.classList.add('shape-bg');
        gameTitleEl.textContent = '–ò–≥—Ä–∞ ¬´–ù–∞–π–¥–∏ —Ñ–æ—Ä–º—É¬ª';
      } else {
        bodyEl.classList.add('both-bg');
        gameTitleEl.textContent = '–ò–≥—Ä–∞ ¬´–¶–≤–µ—Ç + —Ñ–æ—Ä–º–∞¬ª';
      }

      showScreen('gameScreen');
      newRound();
    }

    function newRound() {
      shapesCont.innerHTML = '';
      clearHighlights(shapesCont);
      currentTarget = null;
      currentTaskText = '';
      canClick = true;

      if (currentMode === 'color') {
        taskTextEl.innerHTML =
          '–ù–∞–∂–º–∏ –Ω–∞ —Ü–≤–µ—Ç: <span class="highlight" id="taskHighlight"></span>';
        const taskHighlight = document.getElementById('taskHighlight');

        const roundColors = getRandomItems(COLORS, 4);
        const targetColor = getRandomFrom(roundColors);

        currentTarget = { colorKey: targetColor.key };
        taskHighlight.textContent = targetColor.nameRu;
        currentTaskText = '–ù–∞–∂–º–∏ –Ω–∞ ' + targetColor.nameRu + ' —Ü–≤–µ—Ç';

        roundColors.forEach(c => {
          const wrap = document.createElement('div');
          wrap.className = 'shape';
          wrap.dataset.color = c.key;

          const inner = document.createElement('div');
          inner.className = 'shape-inner circle';
          inner.style.backgroundColor = c.hex;

          wrap.appendChild(inner);
          shapesCont.appendChild(wrap);
        });

      } else if (currentMode === 'shape') {
        taskTextEl.innerHTML =
          '–ù–∞–∂–º–∏ –Ω–∞ —Ñ–æ—Ä–º—É: <span class="highlight" id="taskHighlight"></span>';
        const taskHighlight = document.getElementById('taskHighlight');

        const roundShapes = getRandomItems(SHAPES, 3);
        const targetShape = getRandomFrom(roundShapes);

        currentTarget = { shapeKey: targetShape.key };
        taskHighlight.textContent = targetShape.nameRu;
        currentTaskText = '–ù–∞–∂–º–∏ –Ω–∞ —Ñ–æ—Ä–º—É ' + targetShape.nameRu;

        roundShapes.forEach(s => {
          const wrap = document.createElement('div');
          wrap.className = 'shape';
          wrap.dataset.shape = s.key;

          const inner = document.createElement('div');
          inner.className = 'shape-inner';

          const colorHex = getRandomFrom(COLORS).hex;

          if (s.key === 'circle') {
            inner.classList.add('circle');
            inner.style.backgroundColor = colorHex;
          } else if (s.key === 'square') {
            inner.classList.add('square');
            inner.style.backgroundColor = colorHex;
          } else if (s.key === 'triangle') {
            inner.classList.add('triangle');
            inner.style.borderBottomColor = colorHex;
          }

          wrap.appendChild(inner);
          shapesCont.appendChild(wrap);
        });

      } else {
        taskTextEl.innerHTML =
          '–ù–∞–π–¥–∏: <span class="highlight" id="taskHighlight"></span>';
        const taskHighlight = document.getElementById('taskHighlight');

        const targetColor = getRandomFrom(COLORS);
        const targetShape = getRandomFrom(SHAPES);

        currentTarget = {
          colorKey: targetColor.key,
          shapeKey: targetShape.key
        };

        const phrase = targetColor.nameRu + ' ' + targetShape.nameRu;
        taskHighlight.textContent = phrase;
        currentTaskText = '–ù–∞–π–¥–∏ ' + phrase;

        const items = [];
        const used = new Set();

        items.push({
          isTarget: true,
          colorKey: targetColor.key,
          shapeKey: targetShape.key
        });
        used.add(targetColor.key + '-' + targetShape.key);

        while (items.length < 4) {
          const c = getRandomFrom(COLORS);
          const s = getRandomFrom(SHAPES);
          const key = c.key + '-' + s.key;
          if (used.has(key)) continue;
          used.add(key);
          items.push({
            isTarget: false,
            colorKey: c.key,
            shapeKey: s.key
          });
        }

        items.sort(() => Math.random() - 0.5);

        items.forEach(item => {
          const wrap = document.createElement('div');
          wrap.className = 'shape';
          wrap.dataset.color = item.colorKey;
          wrap.dataset.shape = item.shapeKey;

          const inner = document.createElement('div');
          inner.className = 'shape-inner';

          const colorHex = COLORS.find(c => c.key === item.colorKey).hex;

          if (item.shapeKey === 'circle') {
            inner.classList.add('circle');
            inner.style.backgroundColor = colorHex;
          } else if (item.shapeKey === 'square') {
            inner.classList.add('square');
            inner.style.backgroundColor = colorHex;
          } else if (item.shapeKey === 'triangle') {
            inner.classList.add('triangle');
            inner.style.borderBottomColor = colorHex;
          }

          wrap.appendChild(inner);
          shapesCont.appendChild(wrap);
        });
      }

      speakTask();
    }

    shapesCont.addEventListener('click', (e) => {
      const shapeEl = e.target.closest('.shape');
      if (!shapeEl || !canClick || !currentTarget) return;

      let isCorrect = false;

      if (currentMode === 'color') {
        const chosenColor = shapeEl.dataset.color;
        isCorrect = chosenColor === currentTarget.colorKey;
      } else if (currentMode === 'shape') {
        const chosenShape = shapeEl.dataset.shape;
        isCorrect = chosenShape === currentTarget.shapeKey;
      } else {
        const chosenColor = shapeEl.dataset.color;
        const chosenShape = shapeEl.dataset.shape;
        isCorrect =
          chosenColor === currentTarget.colorKey &&
          chosenShape === currentTarget.shapeKey;
      }

      if (isCorrect) {
        shapeEl.classList.add('correct');
        score++;
        scoreEl.textContent = score;

        showEmojiBurst(shapeEl, true);

        correctSound.currentTime = 0;
        correctSound.play().catch(() => {});

        canClick = false;
        setTimeout(newRound, 800);
      } else {
        shapeEl.classList.add('wrong');

        showEmojiBurst(shapeEl, false);

        wrongSound.currentTime = 0;
        wrongSound.play().catch(() => {});
        setTimeout(() => shapeEl.classList.remove('wrong'), 400);
      }
    });

    nextBtn.addEventListener('click', newRound);

    backBtn.addEventListener('click', () => {
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
      }
      bodyEl.classList.remove('color-bg', 'shape-bg', 'both-bg');
      bodyEl.classList.add('menu-bg');
      showScreen('menuScreen');
    });

    document.querySelectorAll('.menu-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        startGame(btn.dataset.mode);
      });
    });
  </script>
</body>
</html>
