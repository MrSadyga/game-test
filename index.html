<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ò–≥—Ä—ã: –¶–≤–µ—Ç –∏ –§–æ—Ä–º–∞</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css?v=6" />
  <script src="voice.js"></script>
</head>
<body>
  <!-- –°—Ç–∞—Ä—Ç–æ–≤—ã–π —ç–∫—Ä–∞–Ω -->
  <div class="screen active" id="startScreen">
    <div class="start-inner">
      <button class="start-btn" id="enterGameBtn">–í–æ–π—Ç–∏ –≤ –∏–≥—Ä—É</button>
    </div>
  </div>

  <!-- –ú–µ–Ω—é -->
  <div class="screen" id="menuScreen">
    <div class="screen-inner">
      <h1>–î–µ—Ç—Å–∫–∏–µ –∏–≥—Ä—ã: –¶–≤–µ—Ç –∏ –§–æ—Ä–º–∞</h1>
      <p>–í—ã–±–µ—Ä–∏ –∏–≥—Ä—É:</p>
      <div class="menu-buttons">
        <button class="menu-btn" data-mode="color">
          –ò–≥—Ä–∞ ¬´–ù–∞–π–¥–∏ —Ü–≤–µ—Ç¬ª
        </button>
        <button class="menu-btn" data-mode="shape">
          –ò–≥—Ä–∞ ¬´–ù–∞–π–¥–∏ —Ñ–æ—Ä–º—É¬ª
        </button>
        <button class="menu-btn" data-mode="both">
          –ò–≥—Ä–∞ ¬´–¶–≤–µ—Ç + —Ñ–æ—Ä–º–∞¬ª
        </button>
      </div>
    </div>
  </div>

  <!-- –≠–∫—Ä–∞–Ω –∏–≥—Ä—ã -->
  <div class="screen" id="gameScreen">
    <div class="screen-inner">
      <h2 id="gameTitle">–ò–≥—Ä–∞</h2>

      <div class="task" id="taskText">
        –ù–∞–∂–º–∏ –Ω–∞ —Ü–≤–µ—Ç: <span class="highlight" id="taskHighlight">...</span>
      </div>

      <div class="shapes" id="shapes"></div>

      <div class="info">
        –°—á—ë—Ç: <span class="score" id="score">0</span>
      </div>

      <div class="btn-row">
        <button class="btn" id="nextBtn">–°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥</button>
        <button class="btn secondary" id="backBtn">–ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é</button>
      </div>

      <!-- –°–ª–æ–π –¥–ª—è —Å–º–∞–π–ª–∏–∫–æ–≤ -->
      <div id="emojiLayer" class="game-emoji-layer"></div>
    </div>
  </div>

  <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —É—Ä–æ–≤–Ω—è -->
  <div id="levelCompleteModal" class="level-modal">
    <div class="screen-inner">
      <h2>–ú–æ–ª–æ–¥–µ—Ü!</h2>
      <p>–¢—ã –Ω–∞—à—ë–ª 20 —Ü–≤–µ—Ç–æ–≤ –ø–æ–¥—Ä—è–¥!</p>
      <div class="level-image-wrap">
        <img src="images.jpg" alt="–ü–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ" />
      </div>
      <p>–ü–æ–¥–Ω–∏–º–∏—Å—å –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å –∏ –ø–æ–ø—Ä–æ–±—É–π –∏–≥—Ä—É ¬´–ù–∞–π–¥–∏ —Ñ–æ—Ä–º—É¬ª.</p>
      <div class="btn-row">
        <button class="btn" id="nextLevelBtn">–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å</button>
      </div>
    </div>
  </div>

  <script>
    const bodyEl = document.body;

    const COLORS = [
      { key: 'red',    nameRu: '–∫—Ä–∞—Å–Ω—ã–π',    hex: '#ef4444' },
      { key: 'blue',   nameRu: '—Å–∏–Ω–∏–π',      hex: '#3b82f6' },
      { key: 'green',  nameRu: '–∑–µ–ª—ë–Ω—ã–π',    hex: '#22c55e' },
      { key: 'yellow', nameRu: '–∂—ë–ª—Ç—ã–π',     hex: '#eab308' },
      { key: 'purple', nameRu: '—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π', hex: '#a855f7' },
      { key: 'orange', nameRu: '–æ—Ä–∞–Ω–∂–µ–≤—ã–π',  hex: '#f97316' }
    ];

    const SHAPES = [
      { key: 'circle',   nameRu: '–∫—Ä—É–≥' },
      { key: 'square',   nameRu: '–∫–≤–∞–¥—Ä–∞—Ç' },
      { key: 'triangle', nameRu: '—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫' }
    ];

    const COLOR_LEVEL_GOAL = 20;
    const SHAPE_LEVEL_GOAL = 20;
    const BOTH_LEVEL_GOAL  = 20;

    const HINT_PHRASES = [
      '–î–∞–≤–∞–π –ø–æ–¥—É–º–∞–µ–º –µ—â—ë.',
      '–ü—Ä–∏—Å–º–æ—Ç—Ä–∏—Å—å –ø–æ–ª—É—á—à–µ.',
      '–¢—ã —É–∂–µ —Ä—è–¥–æ–º, –ø–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.'
    ];

    const startScreen  = document.getElementById('startScreen');
    const enterGameBtn = document.getElementById('enterGameBtn');
    const menuScreen   = document.getElementById('menuScreen');
    const gameScreen   = document.getElementById('gameScreen');
    const gameTitleEl  = document.getElementById('gameTitle');
    const taskTextEl   = document.getElementById('taskText');
    const shapesCont   = document.getElementById('shapes');
    const scoreEl      = document.getElementById('score');
    const nextBtn      = document.getElementById('nextBtn');
    const backBtn      = document.getElementById('backBtn');
    const emojiLayer   = document.getElementById('emojiLayer');

    const levelCompleteModal = document.getElementById('levelCompleteModal');
    const nextLevelBtn       = document.getElementById('nextLevelBtn');

    let currentMode = 'color';   // 'color' | 'shape' | 'both'
    let currentTarget = null;    // { colorKey?, shapeKey? }
    let currentTaskText = '';
    let score = 0;
    let canClick = true;

    const correctSound = new Audio('./correct.mp3');
    const wrongSound   = new Audio('./wrong.mp3');
    correctSound.volume = 0.7;
    wrongSound.volume   = 0.7;

    const bgMusic = new Audio('./d.mp3');
    bgMusic.loop = true;
    bgMusic.volume = 0.25;

    const menuMusic = new Audio('./c.mp3');
    menuMusic.loop = true;
    menuMusic.volume = 0.25;

    const transitionSound = new Audio('./wau.mp3');
    transitionSound.volume = 0.9;

    bodyEl.classList.add('menu-bg');

    function showScreen(id) {
      startScreen.classList.remove('active');
      menuScreen.classList.remove('active');
      gameScreen.classList.remove('active');
      document.getElementById(id).classList.add('active');
    }

    function getRandomFrom(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function getRandomItems(arr, count) {
      const pool = [...arr];
      const res = [];
      while (res.length < count && pool.length > 0) {
        const idx = Math.floor(Math.random() * pool.length);
        res.push(pool.splice(idx, 1)[0]);
      }
      return res;
    }

    function clearHighlights(container) {
      container.querySelectorAll('.shape').forEach(el => {
        el.classList.remove('correct', 'wrong');
      });
    }

    function speakTask() {
      if (currentTaskText && typeof speak === 'function') {
        speak(currentTaskText, 'ru-RU');
      }
    }

    function speakWrongHint() {
      if (typeof speak !== 'function') return;
      const phrase = HINT_PHRASES[Math.floor(Math.random() * HINT_PHRASES.length)];
      speak(phrase, 'ru-RU');
    }

    function startBackgroundMusic() {
      try {
        bgMusic.currentTime = 0;
        bgMusic.play().catch(() => {});
      } catch (e) {}
    }

    function stopBackgroundMusic() {
      try {
        bgMusic.pause();
      } catch (e) {}
    }

    function startMenuMusic() {
      try {
        menuMusic.currentTime = 0;
        menuMusic.play().catch(() => {});
      } catch (e) {}
    }

    function stopMenuMusic() {
      try {
        menuMusic.pause();
      } catch (e) {}
    }

    function showEmojiBurst(targetEl, isCorrect) {
      if (!emojiLayer || !targetEl) return;

      const emojis = isCorrect
        ? ['üòÄ','üòÑ','üéâ','‚≠ê','üëè']
        : ['üòï','üòû','üôà','‚òÅÔ∏è'];

      const rect = targetEl.getBoundingClientRect();
      const parentRect = emojiLayer.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2 - parentRect.left;
      const centerY = rect.top + rect.height / 2 - parentRect.top;

      const count = 5;
      const radius = 80;

      for (let i = 0; i < count; i++) {
        const span = document.createElement('span');
        span.className = 'emoji-burst';
        span.textContent = emojis[Math.floor(Math.random() * emojis.length)];

        const baseAngle = (Math.PI * 2 * i) / count;
        const angle = baseAngle + (Math.random() - 0.5) * 0.5;

        const dx = Math.cos(angle) * radius;
        const dy = Math.sin(angle) * radius;

        span.style.left = (centerX + dx) + 'px';
        span.style.top  = (centerY + dy) + 'px';

        emojiLayer.appendChild(span);
        setTimeout(() => span.remove(), 1100);
      }
    }

    function showLevelComplete() {
      if (levelCompleteModal) {
        const titleEl = levelCompleteModal.querySelector('h2');
        const pEls = levelCompleteModal.querySelectorAll('p');

        if (currentMode === 'color') {
          if (titleEl) titleEl.textContent = '–ú–æ–ª–æ–¥–µ—Ü!';
          if (pEls[0]) pEls[0].textContent = '–¢—ã –Ω–∞—à—ë–ª 20 —Ü–≤–µ—Ç–æ–≤ –ø–æ–¥—Ä—è–¥!';
          if (pEls[1]) pEls[1].textContent = '–ü–æ–¥–Ω–∏–º–∏—Å—å –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å –∏ –ø–æ–ø—Ä–æ–±—É–π –∏–≥—Ä—É ¬´–ù–∞–π–¥–∏ —Ñ–æ—Ä–º—É¬ª.';
        } else if (currentMode === 'shape') {
          if (titleEl) titleEl.textContent = '–û—Ç–ª–∏—á–Ω–æ!';
          if (pEls[0]) pEls[0].textContent = '–¢—ã –Ω–∞—à—ë–ª 20 —Ñ–æ—Ä–º –ø–æ–¥—Ä—è–¥!';
          if (pEls[1]) pEls[1].textContent = '–¢–µ–ø–µ—Ä—å –ø–æ–ø—Ä–æ–±—É–µ–º –∏–≥—Ä—É ¬´–¶–≤–µ—Ç + —Ñ–æ—Ä–º–∞¬ª!';
        } else if (currentMode === 'both') {
          if (titleEl) titleEl.textContent = '–£—Ä–∞! –¢—ã —á–µ–º–ø–∏–æ–Ω!';
          if (pEls[0]) pEls[0].textContent = '–¢—ã –æ—Ç–ª–∏—á–Ω–æ —Å–ø—Ä–∞–≤–∏–ª—Å—è —Å —Ü–≤–µ—Ç–∞–º–∏ –∏ —Ñ–æ—Ä–º–∞–º–∏!';
          if (pEls[1]) pEls[1].textContent = '–ú–æ–∂–µ—à—å –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é –∏ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∑–∞–Ω–æ–≤–æ –∏–ª–∏ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –∏–≥—Ä—É.';
        }

        levelCompleteModal.classList.add('active-modal');
      }

      try {
        transitionSound.currentTime = 0;
        transitionSound.play().catch(() => {
          speakCongratsAfterWau();
        });
        transitionSound.onended = () => {
          speakCongratsAfterWau();
        };
      } catch (e) {
        speakCongratsAfterWau();
      }
    }

    function speakCongratsAfterWau() {
      if (typeof speak !== 'function') return;

      if (currentMode === 'color') {
        speak('–ú–æ–ª–æ–¥–µ—Ü! –¢—ã –ø—Ä–æ—à—ë–ª —É—Ä–æ–≤–µ–Ω—å. –¢–µ–ø–µ—Ä—å –ø–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —Ñ–æ—Ä–º—É.', 'ru-RU');
      } else if (currentMode === 'shape') {
        speak('–û—Ç–ª–∏—á–Ω–æ! –¢—ã –Ω–∞—à—ë–ª –≤—Å–µ —Ñ–æ—Ä–º—ã. –¢–µ–ø–µ—Ä—å –ø–æ–∏–≥—Ä–∞–µ–º –≤ —Ü–≤–µ—Ç –∏ —Ñ–æ—Ä–º—É –≤–º–µ—Å—Ç–µ.', 'ru-RU');
      } else if (currentMode === 'both') {
        speak('–£—Ä–∞! –¢—ã –ø—Ä–æ—à—ë–ª –≤—Å–µ —É—Ä–æ–≤–Ω–∏. –ú–æ–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é –∏ –ø–æ–∏–≥—Ä–∞—Ç—å –µ—â—ë —Ä–∞–∑.', 'ru-RU');
      }
    }

    function hideLevelComplete() {
      if (levelCompleteModal) {
        levelCompleteModal.classList.remove('active-modal');
      }
    }

    if (nextLevelBtn) {
      nextLevelBtn.addEventListener('click', () => {
        hideLevelComplete();

        if (currentMode === 'color') {
          startGame('shape');
        } else if (currentMode === 'shape') {
          startGame('both');
        } else if (currentMode === 'both') {
          stopBackgroundMusic();
          bodyEl.classList.remove('color-bg', 'shape-bg', 'both-bg');
          bodyEl.classList.add('menu-bg');
          showScreen('menuScreen');
          startMenuMusic();
        }
      });
    }

    function startGame(mode) {
      currentMode = mode;
      score = 0;
      scoreEl.textContent = score;

      bodyEl.classList.remove('menu-bg', 'color-bg', 'shape-bg', 'both-bg');
      if (mode === 'color') {
        bodyEl.classList.add('color-bg');
        gameTitleEl.textContent = '–ò–≥—Ä–∞ ¬´–ù–∞–π–¥–∏ —Ü–≤–µ—Ç¬ª';
      } else if (mode === 'shape') {
        bodyEl.classList.add('shape-bg');
        gameTitleEl.textContent = '–ò–≥—Ä–∞ ¬´–ù–∞–π–¥–∏ —Ñ–æ—Ä–º—É¬ª';
      } else {
        bodyEl.classList.add('both-bg');
        gameTitleEl.textContent = '–ò–≥—Ä–∞ ¬´–¶–≤–µ—Ç + —Ñ–æ—Ä–º–∞¬ª';
      }

      showScreen('gameScreen');
      stopMenuMusic();
      startBackgroundMusic();
      newRound();
    }

    function newRound() {
      shapesCont.innerHTML = '';
      clearHighlights(shapesCont);
      currentTarget = null;
      currentTaskText = '';
      canClick = true;

      if (currentMode === 'color') {
        taskTextEl.innerHTML =
          '–ù–∞–∂–º–∏ –Ω–∞ —Ü–≤–µ—Ç: <span class="highlight" id="taskHighlight"></span>';
        const taskHighlight = document.getElementById('taskHighlight');

        const roundColors = getRandomItems(COLORS, 4);
        const targetColor = getRandomFrom(roundColors);

        currentTarget = { colorKey: targetColor.key };
        taskHighlight.textContent = targetColor.nameRu;
        currentTaskText = '–ù–∞–∂–º–∏ –Ω–∞ ' + targetColor.nameRu + ' —Ü–≤–µ—Ç';

        roundColors.forEach(c => {
          const wrap = document.createElement('div');
          wrap.className = 'shape';
          wrap.dataset.color = c.key;

          const inner = document.createElement('div');
          inner.className = 'shape-inner circle';
          inner.style.backgroundColor = c.hex;

          wrap.appendChild(inner);
          shapesCont.appendChild(wrap);
        });

      } else if (currentMode === 'shape') {
        taskTextEl.innerHTML =
          '–ù–∞–∂–º–∏ –Ω–∞ —Ñ–æ—Ä–º—É: <span class="highlight" id="taskHighlight"></span>';
        const taskHighlight = document.getElementById('taskHighlight');

        const roundShapes = getRandomItems(SHAPES, 3);
        const targetShape = getRandomFrom(roundShapes);

        currentTarget = { shapeKey: targetShape.key };
        taskHighlight.textContent = targetShape.nameRu;
        currentTaskText = '–ù–∞–∂–º–∏ –Ω–∞ —Ñ–æ—Ä–º—É ' + targetShape.nameRu;

        roundShapes.forEach(s => {
          const wrap = document.createElement('div');
          wrap.className = 'shape';
          wrap.dataset.shape = s.key;

          const inner = document.createElement('div');
          inner.className = 'shape-inner';

          const colorHex = getRandomFrom(COLORS).hex;

          if (s.key === 'circle') {
            inner.classList.add('circle');
            inner.style.backgroundColor = colorHex;
          } else if (s.key === 'square') {
            inner.classList.add('square');
            inner.style.backgroundColor = colorHex;
          } else if (s.key === 'triangle') {
            inner.classList.add('triangle');
            inner.style.borderBottomColor = colorHex;
          }

          wrap.appendChild(inner);
          shapesCont.appendChild(wrap);
        });

      } else {
        taskTextEl.innerHTML =
          '–ù–∞–π–¥–∏: <span class="highlight" id="taskHighlight"></span>';
        const taskHighlight = document.getElementById('taskHighlight');

        const targetColor = getRandomFrom(COLORS);
        const targetShape = getRandomFrom(SHAPES);

        currentTarget = {
          colorKey: targetColor.key,
          shapeKey: targetShape.key
        };

        const phrase = targetColor.nameRu + ' ' + targetShape.nameRu;
        taskHighlight.textContent = phrase;
        currentTaskText = '–ù–∞–π–¥–∏ ' + phrase;

        const items = [];
        const used = new Set();

        items.push({
          isTarget: true,
          colorKey: targetColor.key,
          shapeKey: targetShape.key
        });
        used.add(targetColor.key + '-' + targetShape.key);

        while (items.length < 4) {
          const c = getRandomFrom(COLORS);
          const s = getRandomFrom(SHAPES);
          const key = c.key + '-' + s.key;
          if (used.has(key)) continue;
          used.add(key);
          items.push({
            isTarget: false,
            colorKey: c.key,
            shapeKey: s.key
          });
        }

        items.sort(() => Math.random() - 0.5);

        items.forEach(item => {
          const wrap = document.createElement('div');
          wrap.className = 'shape';
          wrap.dataset.color = item.colorKey;
          wrap.dataset.shape = item.shapeKey;

          const inner = document.createElement('div');
          inner.className = 'shape-inner';

          const colorHex = COLORS.find(c => c.key === item.colorKey).hex;

          if (item.shapeKey === 'circle') {
            inner.classList.add('circle');
            inner.style.backgroundColor = colorHex;
          } else if (item.shapeKey === 'square') {
            inner.classList.add('square');
            inner.style.backgroundColor = colorHex;
          } else if (item.shapeKey === 'triangle') {
            inner.classList.add('triangle');
            inner.style.borderBottomColor = colorHex;
          }

          wrap.appendChild(inner);
          shapesCont.appendChild(wrap);
        });
      }

      speakTask();
    }

    shapesCont.addEventListener('click', (e) => {
      const shapeEl = e.target.closest('.shape');
      if (!shapeEl || !canClick || !currentTarget) return;

      let isCorrect = false;

      if (currentMode === 'color') {
        const chosenColor = shapeEl.dataset.color;
        isCorrect = chosenColor === currentTarget.colorKey;
      } else if (currentMode === 'shape') {
        const chosenShape = shapeEl.dataset.shape;
        isCorrect = chosenShape === currentTarget.shapeKey;
      } else {
        const chosenColor = shapeEl.dataset.color;
        const chosenShape = shapeEl.dataset.shape;
        isCorrect =
          chosenColor === currentTarget.colorKey &&
          chosenShape === currentTarget.shapeKey;
      }

      if (isCorrect) {
        shapeEl.classList.add('correct');
        score++;
        scoreEl.textContent = score;

        showEmojiBurst(shapeEl, true);

        correctSound.currentTime = 0;
        correctSound.play().catch(() => {});

        const finishedColorLevel = currentMode === 'color' && score >= COLOR_LEVEL_GOAL;
        const finishedShapeLevel = currentMode === 'shape' && score >= SHAPE_LEVEL_GOAL;
        const finishedBothLevel  = currentMode === 'both'  && score >= BOTH_LEVEL_GOAL;

        if (finishedColorLevel || finishedShapeLevel || finishedBothLevel) {
          canClick = false;
          setTimeout(() => {
            showLevelComplete();
          }, 800);
        } else {
          canClick = false;
          setTimeout(newRound, 800);
        }
      } else {
        shapeEl.classList.add('wrong');

        showEmojiBurst(shapeEl, false);

        wrongSound.currentTime = 0;
        wrongSound.play().catch(() => {});

        // —Ç–æ–ª—å–∫–æ –ø–æ–¥—Å–∫–∞–∑–∫–∞, –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è –∑–∞–¥–∞–Ω–∏—è
        speakWrongHint();

        setTimeout(() => shapeEl.classList.remove('wrong'), 400);
      }
    });

    nextBtn.addEventListener('click', newRound);

    backBtn.addEventListener('click', () => {
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
      }
      stopBackgroundMusic();
      bodyEl.classList.remove('color-bg', 'shape-bg', 'both-bg');
      bodyEl.classList.add('menu-bg');
      showScreen('menuScreen');
      startMenuMusic();
    });

    if (enterGameBtn) {
      enterGameBtn.addEventListener('click', () => {
        startMenuMusic();
        showScreen('menuScreen');
        if (startScreen) {
          startScreen.remove();
        }
      });
    }

    document.querySelectorAll('.menu-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        startGame(btn.dataset.mode);
      });
    });
  </script>
</body>
</html>
